/*
Quark Interface Documentation (*.qk):

SV improved Verilog with interfaces, trying to connect modules together with a
single "variable" or connection that slightly reduced the tedium of connecting
tons of slightly differently named wires. This was an improvement, but it had
some limitations, mostly from confusions and ambiguity in the language.

First the user has to declare their own modports to define the direction of
different signals in the interface. This means you could hypothetically build
an interface that connects three or modules coherently with a single interface
instantiation. This also means that multiple modules can be connected to an
interface, with some amount of ambiguity on which of those modules drives the
interface "outputs" from their perspective.

Quark makes a few modifications to this, namely all interfaces are point to 
point (master/slave), and their direction is indicated by all signals either
being an input or output, instead of explicit modports

*/

// Simple interface
interface my_intf {
    output a;
    input b;
}

// Interface with parameters
interface my_param_intf [bit [32] WIDTH] {
    output a;
    output [WIDTH] data;
    input b;
}

// Interface with block signals
interface my_block_intf {
    output {
        bit a;
    }
    input {
        bit b;
    }
}

// Interfaces can contain arbitrary logic as long as they only depend on
// parameters, not signals, since interfaces generate no runtime logic
interface my_param_intf [bit [32] WIDTH] {
    bit [32] width_half = WIDTH / 2;

    output a;
    output [width_half] data;
    input b;
}

// Interfaces can be nested, but a nested interface must also be labeled as an
// input or an output
interface my_nest_intf {
    output my_intf a;
    input my_intf b;
}

// Interfaces if not connected or assigned to will throw an error at compile
// time, unless a default set of values is provided for that interface
// Individual, non-interface, signals in a module will always throw an error
// when not connected to, so interfaces provide a way to handle "optional"
// connections

interface my_default_intf {
    output bit valid;
    output bit [32] data;
    input bit ready_n;

    // It will throw an error if you do not assign values to all of the signals
    // in the interface, for either the input or the output interface
    default {
        valid = 'b0;
        data = 'b0;
        ready_n = 'b1;
    }
}

// If you have nested interfaces and you want to have default behavior as well,
// then the nested interfaces must already have default behavior defined, or 
// you can set all of the default behaviors for the sub-interfaces manually
// if they do not already have default behavior

interface my_non_default_intf {
    output bit valid;
    output bit [32] data;
    input bit ready_n;
}

interface my_nested_default_intf {
    input my_default_intf a;
    output my_non_default_intf b;

    default {
        // We can alter default behavior for a sub-interface
        a.valid = 'b1;
        // b has no defaults so we are forced to set all of them
        b.valid = 'b0;
        b.data = 'b0;
        b.ready_n = 'b1;
    }
}

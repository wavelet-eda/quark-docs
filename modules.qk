/*
Quark Module Documentation (*.qk):

Modules are smallest form of logic that can be constructed as the top level of a
design. Modules can be connected together through a variety of methods, but a
module should really be thought of as a hardware thread.

For instance, instead of having blocks like always_comb and assign statements,
the entire module is single linear control flow. You can also instantiate
modules inside of other modules but "calling a module" works a little different
than it does in either SV or just calling a state-less function.

Warnings are issued if a future assignment is used in a module using other
modules that do not have all of their outputs registered.
*/

module my_simple_module [
    bit [32] WIDTH, // Must be given as a parameter (you don't need param first)
    // You can declare a derived parameter as a constant that cannot be passed
    // in but can be assigned by internal logic
    const bit [32] WIDTH_HALF = WIDTH / 2,
    // You can define a default parameter that does not have to be passed in,
    // but any default parameter requires that all parameters be passed in
    // with labels
    bit [WIDTH_HALF] HEIGHT = 32, // Trailing comma lol
] {

    // You can also create parameter variables in the body of the module
    // but they need to be labeled explicitly so they aren't confused for
    // signals. The compiler could work it out without this, but it becomes
    // a lot less readable if the labels aren't forced to be there.
    param fixed bit [32] ADDR_WIDTH = clog2(WIDTH);

    // Inputs and outputs can be mixed
    input bit [WIDTH] a, b;
    output bit [WIDTH] c;

    c = a + b; // Just do the assignment right here
}

// You can also call one module inside of another module, just like a function
// but you need to use a new keyword since this technically creates new state
// (to be explained later)
module my_nested_module [
    bit [32] WIDTH
] {
    input bit [WIDTH] a, b, c, d;
    output bit [WIDTH] e;

    // All variables default to zero (you cannot infer a latch)
    bit [WIDTH] temp1, temp2;
    temp1 = new my_simple_module [WIDTH] (a, b);
    temp2 = new my_simple_module [WIDTH] (c, d);
    e = new my_simple_module [WIDTH] (temp1, temp2);
}

// // You can list out the module parameters ahead of time and use the module
// // multiple times as well
// module my_nested_module (
//     param bit [32] WIDTH,
//     input bit [WIDTH] a, b, c, d,
//     output bit [WIDTH] e,
// ) {
//     bit [WIDTH] temp1, temp2;
    
//     // Parameter name matching works the same inside <> as ()
//     my_simple_module<.WIDTH> my_parameterized_module;

//     // We got the parameters out of the way
//     my_parameterized_module(a, b, temp1);
//     my_parameterized_module(c, d, temp2);
//     my_parameterized_module(temp1, temp2, e);
// }

// While the unnamed passing style is normal and generally acceptable for
// functions, it becomes incredibly error-prone when you have a lot of values
// For this reason, named port assignments just like SV are supported
module my_nested_explicit_module [
    bit [32] WIDTH
] {
    input bit [WIDTH] a, b, c, d;
    output bit [WIDTH] e;

    bit [WIDTH] temp1, temp2;

    // You can pass everything labeled as well as left-hand expressions 
    {c: temp1} = new my_simple_module [WIDTH: WIDTH] (a: a, b: b);
    {c: temp2} = new my_simple_module [WIDTH: WIDTH] (a: c, b: d);
    
    // Of note here is that these modules are still like function calls, as in 
    // their ordering matters. If you called the module doing a + b after the
    // module doing temp1 + temp2 then you will have different behavior
    {c: e} = new my_simple_module [WIDTH: WIDTH] (a: temp1, b: temp2);
}

// You can list out the module parameters ahead of time and use the module
// multiple times as well
module my_nested_module [
    bit [32] WIDTH
] {
    input bit [WIDTH] a, b, c, d;
    output bit [WIDTH] e;

    bit [WIDTH] temp1, temp2;
    
    // Parameter name matching works the same inside <> as () but you can only
    // list parameters, but you have to define all of the parameters
    typedef my_simple_module [WIDTH] my_parameterized_module;

    // We got the parameters out of the way
    temp1 = my_parameterized_module(a, b);
    temp2 = my_parameterized_module(c, d);
    e = my_parameterized_module(temp1, temp2);
}

// // The collection of inputs or outputs that make up a module also form an
// // implicitly defined type and can be used inline in code
// module my_typed_module2 (
//     param bit [32] WIDTH,
//     input bit [WIDTH] a, b, c, d,
//     output bit [WIDTH] e,
// ) {
//     bit [WIDTH] temp1, temp2;
    
//     // Parameter name matching works the same inside <> as ()
//     typedef my_simple_module<.WIDTH> my_parameterized_module;

//     // Left hand assignment syntax, with explict struct naming
//     input<my_parameterized_module> temp_inputs;
//     output<my_parameterized_module> temp_outputs1, temp_outputs2;

//     temp_inputs.a = a;
//     temp_inputs.b = b;
//     temp_outputs1 = my_parameterized_module(temp_inputs);

//     temp_inputs.a = c;
//     temp_inputs.b = d;
//     temp_outputs2 = my_parameterized_module(temp_inputs);

//     // You can also pass the parameters with the signals
//     e = my_simple_module(WIDTH, temp_outputs1.c, temp_outputs2.c);
// }

// You can add state to modules through registers or latches, which require a
// clock and an optional reset
module my_state_module (
    param bit [32] WIDTH,
    input bit clk, rst,
    input bit [WIDTH] a, b,
    output bit [WIDTH] c,
) {
    reg bit state_reg(clk, rst);
    reg bit value_reg(clk); // Optional reset
    c = a + b;

    value_reg = c[0]; // Just do the assignment right here
}

// If you have a struct where you want to mix clocks and resets amongst
// different fields of a struct you can define that as well
struct my_struct_t {
    bit [8] state;
    bit [8] my_value;
    bit [8] stuff;
}

module my_state_struct_module (
    param bit [32] WIDTH,
    input bit clk, rst,
    input bit [WIDTH] a, b,
    output bit [WIDTH] c,
) {
    reg my_struct_t my_struct(clk, rst); // You can do the whole struct at once

    // You can label the fields specifically
    reg my_struct_t my_struct_specific {
        reg state(clk, rst);
        reg my_value(clk);
        // If you don't label a field it is not assigned a register and behaves
        // like a normal variable
    }

    my_struct_specific.state = a;
    my_struct_specific.value = b;

    c = a + b;
}

// You can also define outputs as registers too
module my_incr_module (
    param bit [32] WIDTH,
    input bit clk, rst,
    input bit [WIDTH] a,
    output reg bit [WIDTH] b(clk, rst),
) {
    b = a + 'b1;
}

// If you want to assign to a value in the past, say if you have two modules
// that you need to stitch their inputs and outputs to each other respectively,
// then you can use future assignments. You can get combinational loops with 
// this really easily so a variety of warnings will be issued depending on how
// they are used.
module my_state_struct_module (
    param bit [32] WIDTH,
    input bit clk, rst,
    output bit [WIDTH] stage1, stage2,
) {
    future bit [WIDTH] stage2_output;

    bit [WIDTH] stage1_output = my_incr_module(WIDTH, stage2_output);

    // You cannot assign to a future value in an if-statement or multiple times
    // and it must appear in the same scope, not above or below. Future
    // assigments can be put in an if-statement controlled by parameters but
    // it has to resolve to a single assignment
    stage2_output = my_incr_module(WIDTH, stage1_output);

    stage1 = stage1_output;
    stage2 = stage2_output;
}
